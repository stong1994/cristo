+++

date = 2022-01-06T17:05:00+08:00
title = "查询、插入、删除、更新一条MySQL记录都经历了什么"
url = "/internet/MySQL/curd"

+++



一直对MySQL这个黑盒子是如何运行的不甚清楚，因此在这里总结下。

先来了解下MySQL体系架构。

# MySQL体系架构

![](https://raw.githubusercontent.com/stong1994/images/master/picgo/20211006171205.jfif)

*图片来自: https://segmentfault.com/a/1190000039693313*

以上图为对照，MySQL的查询会经历大致以下过程：

1. 客户端与服务端建立连接
2. 查询缓存
3. 将请求的SQL进行解析，并进行语法校验
4. 通过优化器来优化SQL，生成执行计划
5. 选择对应的存储引擎来执行计划，获取数据
6. 向客户端返回查询结果

那么我们就来分别看看这几步都做了哪些事情。

# 建立连接

客户端与服务端的连接本质上是进程间的通信，进程之间的通信方式有：管道、命名管道、命名字、TCP/IP套接字、UNIX域套接字。我们只讨论最常见的TCP/IP套接字。

```bash
mysql -h 127.0.0.1 -u root -p
```

连接时会查询`mysql.user`表进行权限校验。

> MySQL的通信协议是半双工的——在任意时刻，要么客户端向服务端发送数据，要么服务端向客户端发送数据。

# 查询缓存

如果操作为查询，并且MySQL服务器开启了查询缓存，那么MySQL服务器会对sql进行缓存命中。

这个缓存是由大小写敏感的哈希查找实现的，对sql的任何改动都会导致不能命中缓存。

# 解析sql

在这一步会校验sql是否符合语法，并将sql解析为token。

# 查询优化

MySQL使用基于成本的优化器。成本分为IO成本和CPU成本，MySQL会定义每种操作对应的代价。大致流程为：

1. 根据搜索条件，找出所有可能使用的索引
2. 计算全表扫描的代价
3. 计算使用不同索引执行查询的代价
4. 对比各种方案，选择成本最低的那个

# 执行语句

只讨论增删改查。

## 读取记录的过程

### 缓存都做了什么

InnoDB是以页为单位进行磁盘IO的，如果每次读取都要从磁盘读取，那么性能会很差。因此引入了缓存池——`BufferPool`，而从磁盘中加载到缓冲池中的页我们称为**缓冲页**。

每次读取数据页时，都从一个**哈希表**（key为表空间号+页号，value为控制块）中**定位**到**缓冲页对应的控制块**，如果不存在，则从磁盘进行读取，如果存在，则直接读取缓存。

每次从磁盘读取数据页时，都会在`Buffer Pool`中的**free链表**中获取空闲页，并**填充缓冲页对应的控制块**（我们需要这个结构来快速定位到目标缓冲页）。

InnoDB还引入了LRU链表来淘汰最近最少使用的缓冲页（参考[InnoDB中的LRU链表]()）。



### 在聚簇索引中定位一条记录

#### 通过索引页定位数据页

1. 在**索引页**中，通过**二分法**定位记录所在的**槽**，这个槽对应着索引所在的**索引记录组**。（索引记录被分成多组，每组的最小值存入Page Directory，称为槽slot）
2. 在**索引记录组**中通过`next_record`字段来**遍历**整个组，找到记录所在的索引页数据（主键+页号）
3. 通过**页号**找到**下一层树**的**目标索引页**
4. 重复上述3个步骤，直到找到最后一层树——即数据页

#### 在数据页中定位目标记录

1. 在**数据页**中找到`Page Directory`，通过**二分法**定位目标记录所在的**槽**（记录被分成多组，每组的最大值（*思考为什么是最大值而不是最小值*）存入Page Directory，称为槽slot）
2. 通过`Page Directory`找到**上一个槽**，其对应的记录为该组的最大值，然后通过`next_record`来找到**目的槽中的最小值**，接着通过`next_record`来**遍历整个目的组**找到目标记录。

### 在二级索引中定位一条记录

定位方式同聚簇索引相同，不同之处在于**二级索引中的数据页存储的是主键而不是完整的记录**，因此需要通过主键进行**回表**查询。

### 锁和事务

#### 事务中不加锁的读

在事务中，如果读操作没有加锁，那么会生成一个ReadView来保证每次读到事务开始前已提交的数据（可重复读的隔离级别下每个事务中的多次读取复用同一个ReadView，读已提交的隔离界别下每次读取都会生成一个新的ReadView）

#### 事务中加锁的读

对读加锁有两种方式：

- `SELECT .. LOCK IN SHARE MODE; `: 这是一个S锁
- `SELECT ... FOR UPDATE;`: 这是一个X锁

通过对读操作加锁，从而阻止其他事务对目的记录进行修改（在有些场景，我们不允许其他事务对我们正在读取的记录进行修改）。

进行加锁操作也能使在可重复读级别下完全避免幻读（参考[MVCC产生幻读的特殊情况]()）。



## 插入记录的过程

如果创建表时没有定义主键且没有建立NOT NULL的唯一的索引键，那么InnoDB会创建一个隐式列row_id作为主键。因此需要对每一条记录生成一个row_id。

### row_id的赋值步骤

1. 服务器在内存中维护一个全局变量，每当向包含row_id的表中插入一条记录时，获取这个变量作为row_id的值，并把这个全局变量自增1
2. 每当全局变量的值变为256的倍数时，就会将该变量写入系统表空间中
3. 当系统启动时，将系统表空间中的该变量加上256加载到内存中（加256是为了确保内存中的值一定比记录中已存在的row_id值大）

### 自增列的数据生成

自增数据的生成需要用到锁，有两种情况：

1. 自增锁：这是一个表级别的锁，生成数据时，需要先获取锁，语句执行后再释放
2. 轻量级锁：生成数据时进行获取锁，生成数据完成后即释放，不用等待语句执行

### 确定插入位置

1. 通过聚簇索引的目录项找到数据页

2. 再通过数据页的页目录找到数据应存储的槽
   1. 如果槽对应的记录组的记录数量小于8个，那么直接插入到这个记录组中
   2. 如果槽对应的记录组的记录数量为8个，那么就需要将这个组分成两个组，存储主键较小的组中存放5条数据，同时在页目录中新增一个槽

### 申请空间

确定插入位置后，需要申请空间进行存储记录。

1. 如果数据页中有足够的空闲空间，那么直接使用剩余的空间即可。
2. 如果数据页中没有足够的空闲空间，且新记录主键的值大于已有的记录，那么就申请一个新的页来存储。

2. 如果数据页中没有足够的空闲空间，且新记录主键不是最大值，那就去垃圾链表中找到第一个记录，看所占空间是否足够存储新记录

   1. 如果足够，那么就将这个部分空间给到新记录，将多余的空间增加到PAGE HEADER中的可重用空间大小属性（PAGE_GARBAGE）。

   2. 如果垃圾链表中首个记录的空间不足以存储新记录，那么就查看整个页的可重用空间加上空闲空间是否足够存储新记录。
        1. 如果足够，那么就重新组织页面——将用户记录写入到一个临时页，然后再将临时页的数据写会到数据页
        2. 如果不够，那么就申请一个新的页，并进行页分裂

### 申请页

1. 数据页所在的段如果已包含32个碎片区，那么直接申请一个完整的区，并在区中申请一个页空间。

2. 数据页所在的段如果未包含32个碎片区，那么从碎片区中申请一个空闲页。
   1. 如果表空间中存在有空闲页的碎片区，那么直接在这个碎片区申请一个空闲页
   2. 如果表空间中的碎片区不包含空闲页，那么在表空间中先申请一个碎片区，然后再申请一个空闲页

### 锁与事务

#### 插入意向锁

如果新记录插入的**间隙被其他事务加了gap锁**，那么插入操作会**阻塞**，并且当前事务在间隙上增加一个**插入意向锁**。插入意向锁能够加速并发插入——**插入意向锁之间并不互斥，对一个间隙内的多条记录，可以同时插入**。

插入意向锁example：

```mysql
终端1：mysql> begin;SELECT * FROM user where id <= 8 for update;#对id小于8的记录加gap锁
终端2: mysql> begin;insert into user(id, name) values(6, '6'); # 此时生成插入意向锁，并进入等待
终端3: mysql> begin;insert into user(id, name) values(7, '7'); # 此时生成插入意向锁，并进入等待
终端1: commit; # 此时终端2和3同时获取到锁，并执行语句。
```

#### 隐式锁

新插入的数据受**隐式锁**保护：当事务在读取一条新插入的记录时，会根据这条记录的事务id来判断是否能够读取。如果**事务id大于Read View中的最大事务id，那么就不能读取**，如果**事务id是Read View中的活跃事务id，那么不能立即读取，需要帮助这条记录创建一个X锁结构，然后再为自己创建一个S锁结构，标识为等待**。

```mysql
终端1: mysql> begin;insert into user(id, name) values(6, '6'); # 此时新记录未提交
终端2: mysql> begin;select * from user where id = 6 LOCK IN SHARE MODE; # 此时为id=6生成X锁，未自身生成S锁，并等待(如果没有加S锁，则不会等待)
终端3: mysql> begin;update user set name = '7' where id = 6; # 此时未获得锁，等待
终端1: commit; # 此时终端2获取到锁，并执行查询语句，能够查询到id=6的记录。
终端2: commit; # 此时终端3获取到锁，并执行update语句，能够正常更新。
```

#### undo log

向undo log中加入一条记录，主要记录事务id、主键信息等，用于执行回滚。

### 二级索引

二级索引记录的插入和聚簇索引相似，但二级索引记录中没有事务id，每次对页进行更新时，需要把Page Header中的最大事务ID进行更新。

## 删除记录的过程

### 找到记录位置

其方式和“插入数据的过程”中的“找到插入位置”相同。

### 删除记录

找到记录后，其删除步骤分两部分：

1. **标记为删除**：每行记录都有一个删除标志位，用于标识记录是否已删除（为了其他事务还能读取到，因此不能立即删除）。并生成对应的undo log
2. 将记录从正常记录链中移除，并**加入到垃圾链表**中，同时更新页的可重用空间、页目录等信息（purge阶段执行）

对于二级索引，根据聚簇索引对二级索引进行更新即可。

## 更新记录的过程

### 找到记录位置

其方式和“插入数据的过程”中的“找到插入位置”相同。

### 更细记录

#### 更新主键

如果需要更新主键，那么其操作为删除操作+插入操作

1. 将旧记录标记为删除（不将其立即加入垃圾链表，因为别的事务还可能用到，后续在purge阶段处理）
2. 对新记录执行插入操作

同时生成两个undo log。

#### 不更新主键

1. 如果新旧记录的各列长度均相同，那么直接进行原地更新，并生成undo log
2. 如果至少有一列的新旧数据长度不同，那么
   1. 将记录立即加入到垃圾链表中
   2. 如果旧记录长度大于新记录，那么新记录可以复用旧记录的空间，否则申请新空间