+++

date = 2022-03-17T20:43:00+08:00
title = "antlr4 with go"
url = "/internet/tool/antlr4-with-go"

toc = true

+++

## 1. 安装antlr4

直接按照 [官网步骤](https://github.com/antlr/antlr4/blob/master/doc/getting-started.md)安装即可。

## 2. 运行example

创建calc.g4并填入以下内容（文件名称和grammar要相同，否则报错）：

```shell
grammar calc;

// Tokens
MUL: '*';
DIV: '/';
ADD: '+';
SUB: '-';
NUMBER: [0-9]+;
WHITESPACE: [ \r\n\t]+ -> skip;

// Rules
start : expression EOF;

expression
   : expression op=('*'|'/') expression # MulDiv
   | expression op=('+'|'-') expression # AddSub
   | NUMBER                             # Number
   ;
```

生成go解析文件：

```shell
antlr -Dlanguage=Go -o parser calc.g4
```

执行完命令后会生成go文件：

```shell
➜  antlr4-go-example tree
.
├── calc.g4
└── parser
    ├── CalcLexer.interp
    ├── CalcLexer.tokens
    ├── calc.interp
    ├── calc.tokens
    ├── calc_base_listener.go
    ├── calc_lexer.go
    ├── calc_listener.go
    └── calc_parser.go
```

添加一个简单的例子：

```go
package main

import (
	"antlr4-go-example/parser"
	"fmt"
	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

func main() {
	// Setup the input
	is := antlr.NewInputStream("1 + 2 * 3")

	// Create the Lexer
	lexer := parser.NewcalcLexer(is)

	// Read all tokens
	for {
		t := lexer.NextToken()
		if t.GetTokenType() == antlr.TokenEOF {
			break
		}
		fmt.Printf("%s (%q)\n",
			lexer.SymbolicNames[t.GetTokenType()], t.GetText())
	}
}

```

安装go依赖包：

```shell
go mod init antlr4-go-example
go mod tidy
```

运行`main.go`，控制台输出：

```sh
NUMBER ("1")
ADD ("+")
NUMBER ("2")
MUL ("*")
NUMBER ("3")
```

## 3. 语法文件详解

```shell
grammar calc;

// Tokens
MUL: '*';
DIV: '/';
ADD: '+';
SUB: '-';
NUMBER: [0-9]+;
WHITESPACE: [ \r\n\t]+ -> skip;

// Rules
start : expression EOF;

expression
   : expression op=('*'|'/') expression # MulDiv
   | expression op=('+'|'-') expression # AddSub
   | NUMBER                             # Number
   ;
```

1. 语法文件通常以grammar开头，并且文件名与定义的grammar相同（该例中文件名必须为calc.g4）。

2. 规则必须以小写字母开头。

3. Token必须以大写字母开头。

4. 使用|来分割一个规则的若干备用分支。

5. 使用圆括号来把Token组成子规则。

6. 用#来为备选分支设置标签，只有被设置了标签的分支才会生成”事件方法“。

7. op用来处理备选分支的监听事件。expression只会生成“进入”和“退出”的事件，因此对备选分支需要进一步细化，因此用op来区分备选分支。因此有两种用来区分备选分支的方法：

   ```js
   expression
      : expression op=('*'|'/') expression // 使用op
      | expression op=('+'|'-') expression
      | NUMBER                            
      ;
   ```

   或

   ```js
   expression
      : expression ('*'|'/') expression # MulDiv // 使用井号
      | expression ('+'|'-') expression # AddSub
      | NUMBER                          # Number
      ;
   ```

   

   

### 语法模式

#### 序列模式

序列即一列元素，如表示一列数字`1,2,3,4,5`则可以表示为`num : INT(,INT)*;`

重复的元素可用圆括号包裹。

- `*`: 表示没有或者多个
- `+`: 表示1个或多个
- `?`: 表示没有或1个

#### 选择模式

即备选分支，用|来分割多个备选分支，如

```shell
field : INT | STRING;
```

如果有多个备选分支同时符合，则选择最前边的备选分支。

#### 词法符号依赖模式

一个词法符号依赖多个词法符号，如

```
expr: '(' field ')'
```

#### ANTLR核心标记

| 用法                 | 描述                          |
| -------------------- | ----------------------------- |
| x                    | 匹配词法符号、规则或者子规则x |
| x..y                 | 匹配一列规则元素              |
| (...\|...\|...)      | 具有备选分支的子规则          |
| x?                   | 匹配x或者忽略它               |
| x*                   | 匹配x 0次或多次               |
| x+                   | 匹配x 1次或多次               |
| r: ...;              | 定义规则r                     |
| r: ... \| ... \|...; | 具有备选分支的规则            |

### 入门专用词法规则

#### 匹配标识符

ANTLR支持正则表达式中用于表 示字符集的缩写：

```js
ID: [a-zA-Z]+; // 匹配一个或多个大小写字符
```

使用序列模式+选择模式：

```js
ID: ('a'..'z' | 'A'..'Z')+; // 匹配一个或多个大小写字符
```



#### 匹配数字

整数：

```js
INT: '0'..'9'+; // 匹配1个或多个数字
```

或者：

```js
INT: [0-9]+; // 匹配1个或多个数字
```

浮点数：

```js
FLOAT: DIGIT+ '.' DIGIT* // 匹配 1. 39. 3.14159等
	| '.' DIGIT+ // 匹配 .14159
	;
	
fragment 
DIGIT : [0-9] // 匹配单个数字
```

将一条规则声明为**fragment**可以告诉ANTLR，该规则本身不是一个词法符号，它只会被其他 的词法规则使用。这意味着我们不能在语法规则中引用DIGIT。

#### 匹配字符串常量

```js
STRING: '"' .*? '"';
```

字符串是用双引号包裹的任意字符序列。

其中`.*`表示任意字符，`?`表示**非贪婪匹配**——若是贪婪匹配，则该表达式能够匹配任意内容。

上述规则不能匹配包含双引号的字符串，需要用转义字符`\`。

```js
STRING: '"' (ESC|.)*? '"';
fragment
ESC: '\\"' | '\\\\' // 双字符序列\" 和\\
```

ANTLR语法本身需要对转义字符`\`进行转义，因此我们需要`\\`来表示单个反斜 杠字符。

`(ESC|.)*? `循环在看到后续子规则含有一个未转义的双引号时终止。

#### 匹配注释和空白字符

当词法分析器匹配到注释和空白字符的时候，我们通常希望将 它们丢弃。这样，语法分析器就不必处理注释和空白字符了。

使用`skip`指令通知词法分析器将它们丢弃.

**丢弃注释：**

```js
LINE_COMMENT: '//' .*? '\n' -> skip ; // 匹配: '//' 任意字符序列 '\n'
COMMENT: '/*' .*? '*/' -> skip ; // 匹配: '/*' 任意字符序列 '*/'
```

**丢弃空白字符：**

```js
WS: ( ' ' | '\t' | '\r' | '\n' )+ -> skip ; 
```

或者：

```
WS: [ \t\r\n]+ -> skip;
```

#### 通用经验

1. 在词法分析器中匹配并丢弃任何语法分析器无须知晓的东西。
2. 由词法分析器来匹配类似标识符、关键字、字符串和数字的常见词法符号。
3. 将语法分析器无须区分的词法结构归为同一个词法符号类型。例如，如果我们的程 序对待整数和浮点数的方式是一致的，那就把它们都归为NUMBER类型的词法符号。 没必要传给语法分析器不同的类型。
4. 将任何语法分析器可以以相同方式处理的实体归为一类。例如，如果语法分析器不 关心XML标签的内容，词法分析器就可以将尖括号中的所有内容归为一个名为TAG的 词法符号类型。
5. 如果语法分析器需要把一种类型的文本拆开处理，那么词法分析器就应 该将它的各组成部分作为独立的词法符号输送给语法分析器。

### 语法规则

#### 右递归

如`2^2^2`表示`2^4`而非`4^2`，即 需要先计算右边后计算左边。

这时需要指定后缀`<assoc=right>`，即：

```js
expr '^'<assoc=right> expr
```



 ### 词法和语法优先级机制

```js
grammar test;
enumDef : 'enum' '{'...'}';
...
FOR : 'for';
...
ID : [a-zA-Z]+; //不会匹配enum和for
```

1. ANTLR从文法规则中筛选出所有的字符串常量， 并将它们和词法规则放在一起。'enum'这样的字符串常量被隐式定义为词法规则， 然后放置在文法规则之后、显式定义的词法规则之前.
2. ANTLR词法分析器解决歧义问题的方法是**优先使用位置靠前的词法规则**。这意味着，ID规则必须定义在所有的关键字规则之后，在上面的例子中，它在FOR规则之后。ANTLR将为字符串常量隐式生 成的词法规则放在显式定义的词法规则之前，所以它们总是拥有最高的优先级。因 此，在本例中，'enum'被自动赋予了比ID更高的优先级.

## 访问器和监听器

访问器机制和监听器机制的最大的区别在于，监听器的方法会被ANTLR提供的遍历器 对象自动调用，而在访问器的方法中，必须显式调用visit方法来访问子节点。忘记 调用visit()的后果就是对应的子树将不会被访问。

构建应用逻辑和语法松耦合的语言类应用程序的关键在于，令语法分析器建立一棵 语法分析树，然后在遍历该树的过程中触发应用逻辑代码

监听器能够对特定规则的进入和退出事件(即识别到某些词组的事件)作出响

应，这些事件分别由语法分析树遍历器在开始和完成对节点的访问时触发。另外，ANTLR自动生成的语法分析树也支持广为人知的访问者模式，从而允许程序控制语法 分析树的遍历过程。

监听器和访问器机制的最大区别在于，监听器方法不负责显式调用子节点的访问方 法，而访问器必须显式触发对子节点的访问以便树的遍历过程能够正常进行(正如 我们在2.5节中看到的那样)。因为访问器机制需要显式调用方法来访问子节点，所 以它能够控制遍历过程中的访问顺序，以及节点被访问的次数。



这种基于监听器的方法十分巧妙，因为所有的遍历过程和方法触发都是自动进行 的。有些时候，自动进行的遍历反而成为一个缺陷，因为我们无法控制遍历的过 程。例如，我们可能希望遍历一个C语言程序的语法分析树，跳过对代表函数体的子 树的访问，从而达到忽略函数内容的目的。此外，监听器的事件方法也无法利用方 法的返回值来传递数据。当需要控制遍历过程，或者希望事件方法返回值时，我们 可以使用访问者模式

使用访问器方法的代码具有良好的可读性，这是因为它们直接调用其他的访问器方

法来获得局部计算结果，同时能像其他方法一样返回值。这一点既是优点也是缺

点。访问器方法必须显式访问它们的子节点，而监听器无须如此。因为访问器的接

口是通用的，因此在其中无法使用自定义的参数。访问器必须使用其他两种方案之

一来解决调用子节点的访问器方法时的传参问题。



### 三种在事件方法间共享数据的方案

1. 原生语言的调用栈:访问器返回一个用户指定类型的值。不过，如果访问器需要传 递参数，那就必须使用下面两种方案
2. 基于栈的:在上下文类中维护一个栈字段，模拟参数和返回值的入栈和出栈。
3. 标注:在上下文类中维护一个Map字段，用对应的值来标注节点。

## 错误自动恢复

### 通过扫描后续词法符号来恢复

语法分析器知道自己无法使用当前规 则匹配当前输入，它会持续丢弃后续词法符号，直至发现一个可以匹配本规则中断 位置之后的某条子规则的词法符号。

### 从不匹配的词法符号中恢复

在语法分析过程中，如果词法符号不符合预期，就会通知错误监听器并重新同步。为了完成同步，分析器可以在三种策略中选择一个执行：

- 移除一个词法符号
- 添加一个词法符号
- 抛出异常，跳过，继续解析

### 从子规则的错误中恢复

如果子规则是一个循环结构，即`(...)*`或`(...) +`，在遇到错误时，语法分析器会尝试进行积极的恢复，使得自己留在循环内部。在 成功地匹配到循环的某个备选分支之后，语法分析器会持续消费词法符号，直到发现满足下列条件之一的词法符号为止:

1. 循环的另一次迭代
2. 紧跟在循环之后的内容 
3. 当前规则的重新同步集合中的元素

### 捕获失败的语义判定



## 填坑记录

1. java1.8的版本生成的go文件有可能存在一些找不到的方法，最好用更高版本的jdk。

## 相关文档

1. [Parsing with ANTLR 4 and Go]( https://blog.gopheracademy.com/advent-2017/parsing-with-antlr4-and-go/)
1. [文中的代码地址](https://github.com/stong1994/antlr4-go-example)
1. [antlr4用例汇总](https://github.com/antlr/grammars-v4)

