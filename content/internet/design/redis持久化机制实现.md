+++

date = 2022-03-21T11:08:00+08:00
title = "redis持久化机制实现"
url = "/internet/depth/redis_durability"

toc = true 

+++



redis使用内存进行数据的读写，如果服务永不崩溃、服务器不会宕机——redis服务永远正常运行，那么数据就不需要落盘。但目前的技术水平还不能达到这一水准，因此我们还是需要将数据存储到磁盘上。

## RDB

我们可以将内存中的数据直接copy到磁盘中，这种持久化方式就是RDB。

为了防止已经copy到磁盘中的数据被用户修改，因此在copy过程中，redis服务需要拒绝写操作，比如将用户请求先放入队列中，一旦copy结束再从队列中获取请求进行执行。但是这样需要考虑很多条件，redis本着简单、高效的准则，采用了最简单粗暴的方式——拒绝外部请求。

但是拒绝外部请求会导致服务不可用，这是我们不能接受的，因此在copy时redis服务会fork出一个子进程，fork完之后，父进程就可以继续工作，由子进程来进行copy。（copy on write。。。）

## AOF（Append Only File）

RDB持久化最明显的缺点就是缺乏实时性，为了弥补这一点，redis仿照文件追加的方式设计了AOF持久化——每执行一条写命令，就将该命令写到磁盘中。为了减少磁盘IO（毕竟太慢了），redis需要先将命令写入到缓冲队列（aof_buf）中，然后再同步到磁盘中。（事件循环？）

“同步到磁盘”有三种方式：

- 将缓冲队列中的数据直接写入并同步（fsync）到文件中。
- 将缓冲队列中的数据写入到文件中，并每隔一秒进行一次同步。
- 将缓冲队列中的数据写入到文件中，同步操作由操作系统控制。

### AOF重写

随着命令的增多，AOF文件越来越大，为了解决AOF文件膨胀问题，redis提供了文件重写功能。

一个key往往对应着多条命令，为了找到key对应的数据，直接读取内存会更方便。因此，AOF重写的过程就是将内存中的数据copy到AOF文件的过程。在copy过程中，为了redis对外提供服务，因此fork出子进程来实现AOF重写，同时，写命令会存入AOF缓冲区和AOF重写缓冲区分别用于现有AOF文件的同步和AOF重写。重写完成后会将新AOF文件覆盖旧AOF文件。



## 复制积压缓冲区

主服务器在执行完命令后将该命令传播到从服务器，这时如果从服务器发出故障或者网络波动导致命令未在从服务器执行，那么主从之间的数据就会不一致。

为了判断主从之间的数据是否一致需要引入复制偏移量。每当主服务器发送N个字节或者从服务器接收N个字节的数据时，就将复制偏移量加上N。

如果主从之间的复制偏移量不同，那么就需要进行同步。如果只丢失了一小部分数据，那么没必要进行完整的数据同步，所以需要一个结构来存储最近的命令，这个结构就是复制积压缓冲区。

复制积压缓冲区是一个FIFO队列，当主服务器执行完命令后，就会将该命令写入到复制积压缓冲区，然后再将该命令传播到从服务器。

当发现主从服务器之间的复制偏移量不同时（通过ping或者从服务器重启），主服务器会判断从服务器的复制偏移量后的数据是否还在复制积压缓冲区内，如果在，就直接将复制偏移量后的数据发送给从服务器，否则，进行完整的数据同步。

## 哨兵模式

在主从复制的模式，一旦主服务器发生故障，从服务器并不会主动选举出新的master，需要运维手动设置master，这势必会造成一段时间内的服务不可用。为了提高可用性，redis提供了哨兵来监控服务器。

### 服务发现

哨兵会定期发送INFO命令到其监控的服务器中，主服务器会将其角色和从服务器地址返回给哨兵，因此哨兵只要监控主服务器就能获得从服务器的地址。

哨兵会监听同一个频道信息，也会向这个频道报告自己的信息，因此哨兵之间都能够发现彼此。

### 选举领头哨兵

当主服务器发生故障后，需要领头哨兵进行故障转移，redis通过raft算法实现了选举功能。

1. 发起选举后，每个哨兵在每个配置纪元里都能够设置自己认可的leader，一旦确认，在这个配置纪元里就不能再修改
2. 每次选举，配置纪元都会自增
3. “认可”leader的规则依据先来先得，即先接收到的认可请求会被接受，后接受的会被拒绝
4. 选举规则采用多数服从少数，一个哨兵只要被半数以上的哨兵认可就会被选举为leader
5. 如果在给定期限内没有选举出leader，那么会再次进行选举

### 主服务器故障确认

哨兵会定期向其监控的服务器发送PING命令，如果主服务器在一段时间内没有回复，那么哨兵就会认为主服务器故障。

但是每个哨兵配置的超时时间可以是不同的，因此这个哨兵会向其他哨兵确认主服务器是否故障，当超过quorum数量的哨兵认为主服务器已发生故障，那么就可以认为主服务器发生了故障，需要进行转移。需要注意每个哨兵的quorum可以是不同的。

### 故障转移

故障转移需要先在从服务器中选举出主服务器。

1. 排除掉已经下线的从服务器
2. 排除掉与哨兵存在通信故障的从服务器
3. 选择出数据最新的从服务器（根据与旧的主服务器断开时长来判断）
4. 在剩余的从服务器中选择优先级比较高的从服务器
5. 在剩余的从服务器中选择复制偏移量最大的从服务器
6. 在剩余的从服务器中选择id排序最小的从服务器

选出主服务器后，哨兵会向候选服务器发送`slaveof no one`明确将其“提升”为主服务器。然后向其他从服务器发送命令修改复制目标为新主服务器。

如果旧的主服务器上线，上线后会成为从服务器。

## 集群

随着数据量不断膨胀，分布式存储变得日趋重要。redis集群中舍弃了“哨兵”这类管理者，使用分片进行主节点之间的数据切分，使用Gossip协议实现了各个主节点之间的信息共享。

### 分片

redis集群通过分片实现了主节点之间的数据分配。整个集群就是一个数据库，数据库被分为了16384个槽，需要手动分配这些槽到指定节点上。

每个节点都通过长度为16384的二进制数组来标记该节点负责哪些槽，同时又通过另外一个长度为16384的槽来记录每个槽对应的节点信息。

分片规则是通过对键进行CRC16，并对16384取余（实际是&16383），结果即为目标槽，通过上边提到的数组就能获取到目标节点。

当客户端访问一个节点时，如果所需的数据不在当前节点，则当前节点会返回一个MOVE错误，同时返回数据所在的节点地址。客户端收到MOVE错误后，会重新向目标节点请求数据。如果数据所在的节点正在进行重新分片，并且目标数据已被迁移至分片后的节点，那么当前节点会返回一个ASK错误，同时返回数据所在的节点地址，客户端收到ASK错误后，会重新访问分片后的节点请求数据。

### 节点信息共享：Gossip

两个节点之间通过“三次握手”进行连接，连接之后，将彼此的信息通过Gossip协议扩散到其他节点，这些信息包括：

- 新加入节点的地址
- 重新分片后的槽的分配信息
- 节点间的复制关系

集群的节点间会定期发送PING消息来检测对方是否在线，如果每个节点都向所有节点发送消息那么会凭空增大服务器压力，因此对于每个节点，先随机从节点列表中选出5个节点，然后从这5个节点中获取最长时间没有发送PING消息的节点发送PING消息。

### 故障转移

集群中的每个节点都会定期向其他节点发送PING消息来检测对方是否在线，如果对方没有及时回复则会被视为**疑似下线**，节点之间会分享彼此的信息，当集群中半数以上的主节点都认为该节点已下线时（这个如果通过Gossip来实现会不会很慢？），那么这个节点会被标记为已下线，将该节点标记为已下线的主节点会在集群中广播一条FAIL消息，收到FAIL消息的主节点会立即将该节点标记为已下线。

集群会从已下线的主节点的所有从节点中选举出新的主节点：

1. 当从节点发现自己复制的主节点已下线时，会广播一条消息来拉票。
2. 每个有投票权的主节点（有负责的槽）在每个配置纪元里都有一次投票的机会，选举采用先到先得的方式，会投票给第一个收到请求的来源从节点。
3. 当一个从节点获得了半数以上的选票时，会被“升级”为主节点。落选的从节点修改复制目标为新的主节点，当旧的主节点上线时也会自动称为新的主节点的从节点。
4. 如果在一个配置纪元中没有从节点能够获得半数以上的选票，则再次进行选举。





## Pipeline与事务的区别

[参考资料](https://www.zhihu.com/question/422433905)

1. pipeline是客户端的行为，是将多条命令打包到一起发送给服务端。服务端解析这些命令然后执行，并不清楚是否是pipeline。如果这些命令数据较少，能够一次性的写入服务端的输入缓冲区，那么这些命令的执行就不会被打断，但是如果这些命令数据较大，那么这些命令就可能会被分成多次发送给服务端，命令的执行就可能会被打断
2. 执行事务时会阻塞其他命令执行，而pipeline不会
3. pipeline会将命令一次性打包发送到服务单，而事务会一条一条发送



