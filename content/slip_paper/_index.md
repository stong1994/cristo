## 2024.7.8

### 共鸣

早上九点钟骑自行车去公司的路上，看到公家的人在用电锯修剪树木————昔日繁茂的枝头变成了光秃秃的一片————而我的脖子也传来一阵寒意————就像修剪的不是树木的枝头，还是我的头发。

## 2024.5.30

### 所谓“模式”

最近越来越感觉到一个人最终会不会“进化”——实现阶级的跃迁也好、精神上的跃迁也算，并不是由这个人做了哪些事情决定的。
决定人生命运的，往往是由更深层次的模式决定的。什么是模式？
比如说，每天中午吃完饭我都会玩一会游戏再午睡，这种习惯就是一种模式。但是这种模式是最浅的，最容易被发现的，也是影响力最小的模式。因为它很容易就能改变。
更深层次的模式，比如说"遇到很麻烦的问题就会逃避",这种模式会在关键时刻给人致命的打击。这和人的性格无关，因为所谓“性格”是人日常表现出来的性状，当然，性格也可以看做多种“模式”。
在更深一点，人之所以有思维能力，有记忆力，本身就是依赖的神经网络的“模式”。你看到一个歪七扭八的字，能够识别出来这个字，就是因为这个字通过视网膜神经传递给大脑后，匹配上了这个字的模式。
所以，“模式”真是影响人类的重要组成！

## 2024.5.25

### AI焦虑

似乎每个人都在涉猎大量的AI工具，期待AI给自身赋能，但是：

- 首先，AI能够解决的现实问题只占很小一部分（它只能解决可被计算的，能够有结果的，并且在有限步骤内能够得到答案的问题）
- 其次，个人或者团队本身的问题（这些最核心的问题）是无法通过AI解决的
- 最后，我们对AI的执着会让我们忽视掉这些核心问题

### 见诸相非相

《金刚经》里有一句“见诸相非相，即见如来”。可解为：

- 诸相即众生相
- 见诸相非相即见如来，也就是说当你看到的那个相不是众生相时，你就看到了如来
- 那什么不是众生相呢？就是你自己！
- 你可以看到别人的喜怒哀乐，但是看不到自己的喜怒哀乐（应该没人会一边笑的时候一边看镜子）
- 所以当你的喜怒哀乐不同于其他人的喜怒哀乐时，也就是你发现了自己的与众不同时，你就是如来
- 所以，佛学也是一门诉诸于自我觉醒的学问

## 2024.1.13

### 用户、产品与沟通

用户在使用我们的产品时实际上就是在和产品的创造者（也就是我们）交流，如果用户的体验很差，那就是我们的表达能力很差。从这个逻辑上说，如果用户发现了bug，那实际上就是我们“讲的东西”有自相矛盾的地方。

### 信息架构的目的

和现实世界中场所的设计一样，**信息架构的目的**是让用户的需求（想要在一种舒适、熟 悉的环境中查找和理解信息）与拥有环境（通常都拥有要满足的业务目标，例如，某个 销售目标）的组织和全社会的需求达到**平衡**。当达到正确的平衡时，整个组织的产品和 服务（从网站到物理环境的寻路系统）就会有连贯性和可理解性。 **一个经过精心设计的组织结构可以帮助用户理解全新的、不熟悉的环境。**

## 2024.1.12

### 《rust编程之道》：基于消息通信的并发模型

基于消息通信的并发模型主要有两种：Actor模型和CSP模型。

Actor模型的代表语言是Erlang，而CSP模型的代表语言是Golang。这两种并发模型的区别如下：
· 在Actor模型中，主角是Actor，Actor之间直接发送、接收消息；而在CSP模型中，主角是Channel，其并不关注谁发送消息、谁接收消息。
· 在Actor模型中，Actor之间是直接通信的；而在CSP模型中，依靠Channel来通信。
· Actor模型的耦合程度要高于CSP模型，因为CSP模型不关注消息发送者和接收者。

![](https://raw.githubusercontent.com/stong1994/images/master/picgo/202401121017081.png)

## 2024.1.11

### 《rust编程之道》中关于进程、线程、协程的介绍

进程是资源分配的最小单元，线程是程序执行时的最小单元。
从操作系统的角度来看，进程代表操作系统分配的内存、CPU时间片等资源的基本单位，它为程序提供基本的运行环境。不同的应用程序可以按业务划分为不同的进程。从用户的角度来看，进程代表运行中的应用程序，它是动态条件下由操作系统维护的资源管理实体，而非静态的应用程序文件。每个进程都享有自己独立的内存单元，从而极大地提高了程序的运行效率。

进程会占用相当可观的系统资源，还有切换复杂、CPU利用率低、创建和销毁复杂等缺点。

为了寻求比进程更小的资源占用，线程应运而生。线程是进程内的实体，它无法独立存在，必须依靠进程，线程的系统资源都来源于进程，包括内存。每个进程至少拥有一个线程，这个线程就是主线程。每个进程也可以生成若干个线程来并发执行多任务，但只能有一个主线程，线程和线程之间可以共享同一个进程内的资源。一个线程也可以创建或销毁另一个线程，所以线程会有创建、就绪、运行、阻塞和死亡五种状态。每个线程也有自己独享的资源，比如线程栈。

为了解决C10K问题，事件驱动编程应运而生，最知名的就是Linux推出的epoll技术。事件驱动也可以称为事件轮询，它的优点在于编程更加容易，不用做并发设计的考虑，不需要引入锁，不需要考虑内部调度，只需要依赖于事件，最重要的是不会阻塞。所以它可以很方便地和编程语言相集成，比如 Node.js，也就是第一个事件驱动编程模型语言。在 Node.js中，仅仅使用单线程就可以拥有强大的并发处理能力，其力量来源就是事件驱动和异步回调（Callback） 。通过内置的事件循环机制，不断地从事件队列中查询是否有事件发生，当读取到事件时，就会调用和此事件关联的回调函数，整个过程是非阻塞的。

事件驱动和回调函数虽然解决了C10K的问题，但是对于开发者来说还远远没有那么完美。问题就出在回调函数上面，如果编写业务比较复杂的代码，开发者将陷入“回调地狱（Call Hell）
”中。

为了避免“回调地狱”，不停地有新方案被提出，比如Promise和Future
，这两种方案从不同的角度来处理回调函数。Promise 站在任务处理者的角度，将异步任务完成或失败的状态标记到 Promise 对象中。Future 则站在任务调用者的角度，来检测任务是否完成，如果完成则直接获取结果，如果未完成则阻塞直到获取到结果，或者编写回调函数避免阻塞，根据相应的完成状态执行此回调函数。

为了进一步完善基于事件驱动的编程体验，一种叫作协程的解决方案浮出水面。“协程为协同任务提供了一种抽象，这种抽象本质上就是控制流的出让和恢复。协程的这种机制，正好符合现实世界中人类异步处理事务的直觉。

当事件来临时，出让当前的控制权，切换场景，完成该事件，然后再切换回之前的场景，恢复之前的工作。如果说事件驱动编程和异步回调是站在事件发生的角度进行编程的，那么协程就是站在开发者的角度来进行编程的。

## 2023.11.08

### 日本版的量化宽松

1. 日本央行增发货币
2. 用增发的货币买日本的银行债，导致银行债价格提升
3. 把日本的银行债交给越南(example)的银行作为越南增发货币的抵押
4. 越南增发了越南盾，为了避免本土通货膨胀，这些钱定向交给日资企业
5. 日资企业得到大量资金，占据市场

> 越南为什么要增发货币，对越南有何好处？

来源：[温铁军：日本没有军事霸权，为何还能学美国搞量化宽松？【践闻录】 - 北京大学 Peking University - YouTube](https://www.youtube.com/watch?v=E0S2e8Y2MmI&ab_channel=北京大学PekingUniversity)

## 2023.10.27

### 王阳明的“心外无物”中的“物”

> 王阳明的“心外无物”中的“物”并不是指客观存在的事物本身，而是指事物带来的感觉、道德、意境等。
>
> 比如《传习录》中记载的：
>
> “先生游南镇，一友指岩中花树问曰：“天下无心外之物，如此花树在深山中自开自落，于我心亦何相关？”先生曰：“你未看此花时，此花与汝心同归于寂。你来看此花时，则此花颜色一时明白起来，便知此花不在你心外”

## 2023.09.09

### 为什么要看书而不是看博客？

> 因为一本书就是一个范畴，是词语的”无法之地“。因此需要使用一本书的内容去构建这个范畴。否则对作者之外的人来说，无法理解这个知识——因为没有构建范畴——通过构建一个一个类比，来构成一条通往知识的道路。

### 选择的同时也是放弃

> 甚至于，选择的同时意味着放弃了更多。
>
> 比如说我们构建一个消息中台，需要用到消息队列，实现消息队列的中间件有很多，比如kafka、rabbitmq、redis、rocketmq等等。那我们要如何选择呢？
>
> 首先，要明确需求。
>
> 其次，要明确各个中间件支持的功能甚至于实现方式。
>
> 最后，比较、排除，得到最优的中间件。
>
> 在这个选择的过程中，我们要做很多的取舍，“得”的同时也要看到“失”。

## 2023.09.05

### Prometheus'Pull vs Jaeger's Push

> 对于数据的采集，Prometheus使用服务器Pull的方式而Jaeger使用客户端Push的方式，或许是由于Jaeger采集**的链路对象生命周期短**，Prometheus采集的指标对象生命周期长。这样服务器能够更快的释放链路对象所占用的内存；对于指标对象，通常占用内存少，因此不必考虑内存问题，而使用PULL的方式实现更简单。可参考[关于Push与Pull的对比](http://bit.ly/3aJEPxE)
