---

title: "Understanding_the_linux_kernel"
date: 2021-02-06T12:41:21+08:00
draft: true
---

内核：一段程序，当初操作系统启动时，内核被装入到RAM中。

操作系统中最重要的程序是内核。

操作系统必须完成的两个主要目标：

- 与硬件部分交互
- 为应用程序提供执行环境

类Unix系统不允许用户直接访问硬件，需要通过内核来操作。为了实现这一目的，硬件为CPU引入了两个不同的执行模式：

- 用户态:用户程序的非特权模式
- 内核态：内核的特权模式

进程：程序执行的一个实例或者一个运行程序的执行上下文。

程序与进程：几个进程能够并发地执行同一程序，而同一个进程能够顺序的执行多个程序

文件：Unix文件是以字节序列组成的信息载体，内核不解释文件的内容。



## 内存寻址

### 疑问：

如何定义1bit

页目录的作用？为什么有？

实模式？保护模式？

### 内存地址

三种地址：

逻辑地址：包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。

线性地址：也叫虚拟地址，一个32位无符号整数，可用来表示高达4GB的地址（4294967296个内存单元）

物理地址：用于内存芯片级内存单元寻址，与微处理器的地址引脚发送到内存总线上的电信号相对应。由32位到36位无符号整数表示。

内存控制单元（MMU）通过被称为分段单元的硬件电路把一个逻辑地址转换为线性地址；被称为分页单元的硬件电路把线性地址转换为物理地址。

在多处理器系统，所有CPU都共享同一内存，这表示RAM芯片可以由独立的CPU并发地访问。RAM芯片上的读或写操作必须串行的执行，因此需要一种被称为内存仲裁器的硬件电路插在总线和每个RAM芯片之间，其作用为：如果某个RAM芯片空闲，就准许一个CPU访问，如果不空闲，就延迟这个CPU访问。

### 硬件中的分段

从80286模型开始，Intel微处理器以两种不同的方式执行地址转换：实模式和保护模式。

实模式存在的作用：维持处理器与早期模型兼容，并让操作系统自举。

**逻辑地址**由**段标识符**和**偏移量**组成。段标识符是一个16位长的字段，称为**段选择符**，偏移量是一个32位长的字段。

为了快速方便的找到段选择符，处理器提供**段寄存器**，段寄存器唯一目的就是存放段选择符。段寄存器有6个：

- cs 代码段寄存器，指向包含程序指令的段
- ss 栈段寄存器，包含当前程序栈的段
- ds 数据段寄存器，指向包含静态数据或者全局数据段
- es 可指向任意数据段
- fs 可指向任意数据段
- gs 可指向任意数据段

尽管只有6个段寄存器，但程序可以把同一个段寄存器用于不同的目的，方法是先将其值保存在内存中，用完再恢复。

cs寄存器包含一个两位的字段，用以指明CPU的当前特权级（CPL）。0表示最高优先级，3表示最低优先级。Linux只用0级和3级，分别称为内核态和用户态。

**段选择符格式**：

![](https://raw.githubusercontent.com/stong1994/images/master/picgo/20210206141737.png)

- index：制定了放在GDT或LDT中的相应段描述符的入口
- TI：指明段描述符是在GDT(TI=0)中或者再LDT中（TI=1）
- RPL: 请求者特权级

#### 快速访问段描述符

每个段由一个8字节的**段描述符**表示。段描述符放在全局描述符表（GDT）或者局部描述符表（LDT）。**段描述符包含段的首字节的线性地址**

通常只定义一个GDT，每个进程可以有自己的LDT。对应的寄存器为gdtr和ldtr。

为了**加速逻辑地址**到**线性地址**的**转换**，80x86处理器提供一种附加的**非编程的寄存器**（不能被程序员设置），**供6个可编程的段寄存器使用**。每个**非编程的寄存器**含有**8个字节的段描述符**，**由相应的段寄存器中的段选择符来指定**。每当一个**段选择符被装入段寄存器**时，**相应的段描述符**就由内存**装入到对应的非编程CPU寄存器**，因此，处理器**只需直接引用存放段描述符的CPU寄存**器即可获取这个**段的线性地址**

![](https://raw.githubusercontent.com/stong1994/images/master/picgo/20210206144239.png)

#### 分段单元：逻辑地址转换为线性地址

1. 检查**段选择符**中的**TI**字段，找到段描述符保存在哪个**描述符表**中
2. 从**段选择符**的**index**字段计算**段描述符的地址**（index*8），这个值与gdtr或ldtr寄存器中的内容相加
3. 把**逻辑地址**的**偏移量**和**段描述符Base字段**（段的首字节线性地址）的值**相加**得到**线性地址**

#### Linux中的分段

**分段**可以**给每个进程分配不同的线性地址空间**，**分页**可以**把同一线性地址空间映射到不同的物理空间**。

Linux更喜欢使用分页方式：

- 当所有进程使用相同的段寄存器值时，内存管理变得更简单，因为他们能共享同样的一组线性地址
- 可移植性更高

与段相关的线性地址从0开始，达到2^32-1的寻址限长，这意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。

所有段都从0x00000000开始，这意味着在**Linux下逻辑地址和线性地址是一致的**，即逻辑地址的偏移量字段的值和相应的线性地址的值总是一致的。

#### Linux GDT

多处理器中，每个CPU对应一个GDT。

每个GDT包含18个段描述符和14个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的段描述符能够处于同一个32字节的硬件高速缓存行中。

#### Linux LDT

大多数用户态下的Linux程序不适用局部描述符。

#### 硬件中的分页

**分页单元把线性地址转换为物理地址**。分页单元把请求的访问类型与线性地址的访问权限相比较，如果这次访问是无效的，就产生一个缺页异常。

为了效率起见，**线性地址被分成以固定长度为单位的组**，称为**页**。页内部连续的线性地址被映射到连续的物理地址中。

**分页单元把所有的RAM分成固定长度的页框**（也叫物理页），每个页框包含一个页，即页框的长度和页的长度一致。

**页和页框的区别**：页框是主存的一部分，因此也是一个存储区域；页只是一个数据块可以放在任何页框或磁盘中。

**把线性地址映射到物理地址的数据结构称为页表**。**页表存在主存中**，在启用分页单元之前必须由内核对页表进行适当的初始化。

从80386起，Intel处理器的分页单元处理**4KB**的页。

32位线性地址被分成3个域：

- Directory（目录）：最高10位
- Table（页表）：中间10位
- Offset（偏移量）：最低12位

线性地址的转换分两步完成，每一步都基于一种转换表：第一种转换表称为页目录表，第二种转换表称为页表。

使用**二级模式**的**目的**在于**减少每个进程页表所需RAM的数量**。如果使用一级页表，则需要2**20个表项（在每个实体4个字节时，需要4MB的RAM）来表示每个进程的页表，即使一个进程不需要那个范围内的所有地址。二级模式通过只为进程实际使用的那些虚拟内存区请求页表来减少内存使用量。

没必要马上为进程的所有页表分配RAM，只有当进程实际需要一个页表时才给该页表分配RAM。

**80x86处理器的分页**

![](https://raw.githubusercontent.com/stong1994/images/master/picgo/20210206153852.png)

Directory字段和Table字段都是10位长，因此一个页目录可以寻址高达`1024*1024*4096=2^32`个存储单元。

正在使用的页目录的物理地址存放在控制寄存器cr3中。

#### 扩展分页

允许页框的大小为4MB而不是4KB

![](https://raw.githubusercontent.com/stong1994/images/master/picgo/20210206155133.png)

#### 硬件高速缓存

微处理器时钟频率接近几个GHZ，而动态RAM(DRAM)芯片的存取时间是时钟周期的数百倍。当从RAM中设置或者获取结果时，CPU可能等待很长时间。

为了缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存。基于局部性原理，最近最常用的相邻地址在最近的将来被用到的可能性极大，因此，引入小而快的内存来存放最近最常使用的代码和数据变得很有意义。

80x86引入了一个叫行（line）的新单位。行由几十个连续的字节组成，它们以脉冲突发模式在慢速DRAM和快速的静态RAM（SRAM，用来实现高速缓存）之间传送，以实现高速缓存。

高速缓存再被细分为行的子集。大多数高速缓存在某种程度上是N-路相关联的，意味着主存中的任意一行可以存在高速缓存N行中的任意一行。

高速缓存单元插在分页单元和主内存之间，它包含一个硬件高速缓存内存和一个高速缓存控制器。高速缓存内存存放内存中真正的行。高速缓存控制器存放一个表项数组，每个表项对应高速缓存内存中的一个行。每个表项有一个标签和描述高速缓存行状态的几个标志。标签由一些位组成，用来让高速缓存控制器来识别这个行当前映射的内存单元。这种内存物理地址通常分为3组：最高几位队以ing标签，中间几位对应高速缓存控制器的子集索引，最低几位对应行内的偏移量。

**处理器硬件高速缓存**

![](https://raw.githubusercontent.com/stong1994/images/master/picgo/20210206173541.png)

当访问一个RAM存储单元时，CPU从物理地址中提取出子集的索引号并把子集所有行的标签与物理地址的高几位相比较，如果发现某一行的标签与这个物理地址的高位相同，则CPU命中一个高级缓存，否则，未命中。

命中后，对于读操作，控制器从高速缓存行中选择数据并送到CPU寄存器。

对于写操作，控制器有两个基本策略可选：

- 通写：控制器既写RAM，也写高速缓存行，为了提高写效率关闭高速缓存
- 回写：只更新高速缓存行，不改变RAM的内容。只有当CPU执行要求刷新高速缓存表项的指令或者当产生一个FLUSH硬件信号时，高速缓存控制器才把内容写到RAM中

多处理器系统的每一个处理器都有一个单独的硬件高速缓存，因此需要额外的硬件电路用于保持高速缓存的同步。同步操作在硬件级处理，内核无需关心。

#### 转换后援缓冲器TLB

用于加速线性地址的转换。

当一个线性地址第一次使用时，通过慢速访问RAM中的页表计算出相应的物理地址，同时地址被存放在一个TLB表项，以便以后对同一个线性地址的引用可以快速得到转换。

#### Linux中的分页

同时适用于32位和64位的普通分页模型。

采用四级分页模型：

- 页全局目录
- 页上级目录
- 页中间目录
- 页表

对于没有启用物理地址扩展的32位系统，两级页表已经够用了，其中的页上级目录和页中间目录全为0

启用了物理地址扩展的32位系统使用了三级页表，取消了页上级目录。

当内核创建一个新的页全局目录时，同时也分配四个相应的页中间目录，只有当父页全局目录被释放时，这四个页

![](https://raw.githubusercontent.com/stong1994/images/master/picgo/20210206180907.png)

Linux的进程处理很大程度上依赖分页，线性地址到物理地址的自动转换使得下面的设计目标变得可行：

- 给每一个进程分配一块不同的物理空间，有效防止寻址错误。
- 区别页和页框的不同。允许存放在某个页框中的一个页，然后保存到磁盘上，以后重新载入这一页时又可以放在不同的页框。这时虚拟内存机制的基本要素。

每一个进程有它自己的页全局目录和自己的页表集。当发生进程切换时，Linux把cr3控制寄存器的内容保存在前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器中。因此，当新进程重新开始在CPU上执行时，分页单元指向一组正确的页表。

#### 物理地址扩展分页机制PAE

todo

当PAE被激活时，内核使用三级页表。当内核创建一个新的页全局目录时，同时也分配四个相应的页中间目录，只有当父全局目录被释放时，这四个页中间目录才得以释放。

## 番外篇

[页目录、页表、页](https://stackoverflow.com/questions/29945171/difference-between-page-table-and-page-directory#:~:text=In%20the%20x86%20architecture%2C%20page,in%20the%20physical%20memory%20hardware)

页是一个内存块，支持3种大小：4MB, 2MB, 4KB (X86 32位)

页表是一个1024个元素的数组，每个元素都是4bytes的结构体，共4KB，每个结构体都指向了页的物理地址。在页为4KB时，一个页表能够表示1024*4KB=22bits的地址空间，22位明显不能最大化利用一个线性地址（32位）。

页目录也是一个1024*4bytes的数组，每个元素都指向了一个页表。

此时 页目录+页表+页偏移量 = 10+10+12 = 32 = 一个线性地址

size(页目录)=size(页表)=size(页偏移量) = 4kb = 页大小

当CPU访问线性地址（32位）时，使用高10位[31:22]来定位页目录，使用中10位来定位页表[21:12]，使用低12位[11:0]来定位页。

此时，一个线性地址能够定位的页的大小 = `1024*1024*4kb = 4GB`

